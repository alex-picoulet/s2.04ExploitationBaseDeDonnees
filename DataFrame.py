# -*- coding: utf-8 -*-
"""
Spyder Editor

This is a temporary script file..
"""

"""
Fichier: visite avec lien avec la premiere action, exemple la langue de la page,
dans action dans visite mais trop de ligne 

Obtenir un fichier avec la possibilié de rajouter les premiere visites


Parcourir ( for ind in df.index         si ca change on rajoute sinon on ne fait rien
               df.loc[ind,'Id_visit']
            for i in range(len(df))
                df.iloc[i,0])
Un SELECT DISCTINCT

Prob origine
cad selon l'origne les visites sont les meme ? ou nb action/visites, a la meme heure, date
---Utiliser frequentation selon origine---

"""

import pandas as pd
import matplotlib.pyplot as plt

# I M P O R T A T I O N S

# Importation de la table Actions
Actions = pd.read_table('F:\PREMIERE_ANNEE\S2\S2.04Exploitation dune base de données/csv/Actions.csv', 
                        sep=";", 
                        encoding="Latin_1", 
                        index_col=0)

# Importation de la table Localisation
Localisation = pd.read_table('F:\PREMIERE_ANNEE\S2\S2.04Exploitation dune base de données/csv/Localisation.csv',
                             sep=";", 
                             encoding="Latin_1", 
                             index_col=0)

# Importation de la table ActionDansVisites
ActionDansVisites = pd.read_table('F:\PREMIERE_ANNEE\S2\S2.04Exploitation dune base de données/csv/ActionDansVisites.csv',
                                  sep=";", 
                                  encoding="Latin_1")

# Importation de la table Visites
Visites = pd.read_table('F:\PREMIERE_ANNEE\S2\S2.04Exploitation dune base de données/csv/Visites.csv',
                        sep=";", 
                        encoding="Latin_1", 
                        index_col=0)

# Importation de la table Pages
#Pages = pd.read_table('S2.04ExploitationDUneBaseDeDonnees/csv/Pages.csv',
#                        sep=";", 
#                        encoding="Latin_1", 
#                        index_col=0)



# J O I N T U R E S

# jointure Visites et Localisation
visitesLoc = pd.merge(Visites, Localisation, 
                      left_on='Location_city', 
                      right_index=True, 
                      how='inner')

# jointure Visite et ActionDansVisites
visitesActionDansVisites = pd.merge(ActionDansVisites, Visites, 
                                    left_on='Id_visit', 
                                    right_index=True,
                                    how='inner')

# jointure Visites et Localisation
visitesActionDansVisitesActions = pd.merge(visitesActionDansVisites, Actions, 
                      left_on='Id_action', 
                      right_index=True, 
                      how='outer')

# jointure visitesLoc et Actions
visitesActionsLoc = pd.merge(visitesLoc, Actions, 
                      left_on='Id_visit', 
                      right_index=True, 
                      how='outer')

# jointure visitesActionsLoc et ActionDansVisites
visitesActionsLocAcDansVis = pd.merge(visitesActionsLoc, ActionDansVisites, 
                      left_on='Id_visit', 
                      right_index=True, 
                      how='outer')


#
# Sélectionner les lignes où la configuration de l'appareil est windows, Android ou IOS
#visites_os_IOS = Visites.loc[Visites['Config_os'] == 'IOS']
#visites_os_WIN = Visites.loc[Visites['Config_os'] == 'WIN']
#visites_os_AND = Visites.loc[Visites['Config_os'] == 'AND']

# Compter le nombre d'appareils qui ont comme configuration d'OS IOS
#nb_WIN = len(visites_os_WIN)
#nb_IOS = len(visites_os_IOS)
#nb_AND = len(visites_os_AND)

###########Dans le poly de stats, config os , tableau de fréquence sur toutes la modalitées


utilisateurs_ios = visitesLoc.loc[visitesLoc['Config_os']=='IOS',:]
nb_ios = len(utilisateurs_ios)



# Recuperer la premiere action faite et l'heure


# Nombre d'actions par visites
actions_par_visite = visitesActionDansVisitesActions.groupby('Id_visit').size()

# Compter le nombre d'actions par ville de recherche
nombre_actions_villes = visitesActionsLocAcDansVis.groupby(['Nomville']).size().reset_index(name='nombre_actions')

# premiere action dans une visite
premiere_action = visitesActionsLocAcDansVis[['Id_visit', 'Id_action']]



correspConfig = {'AND' : 'Android',
           'WIN' : 'Windows',
           'IOS' : 'ios',
           'MAC' : 'Autres'}

Visites['config'] = Visites['Config_os'].map(correspConfig)




# ETAPE 2

#Localisation.describe()

# Compter les valeurs des variables
tabfreq= Visites['config'].value_counts()
# Avec la méthode plot de Pandas
plt.title('Répartition des systèmes dExploitation des visites')
plt.pie(tabfreq,labels = tabfreq.index ,startangle=90,autopct='%1.f%%',
 counterclock=False)




# PAYS
visitesLoc["nb"] = 1

grap2 = visitesLoc[["Region4", "nb"]].groupby("Region4").sum()# sélectionne les colonnes "Region4" et "nb" du DataFrame visitesLoc et les groupe par région en utilisant 
                                                              #la méthode groupby(). La méthode sum() calcule le nombre total de visites par région en additionnant les 
                                                              #valeurs de la colonne "nb".
grap2.plot(kind="bar",legend=False) #L'argument kind="bar" spécifie que nous voulons un graphique en barres. L'argument legend=False désactive la légende du graphique.
plt.xlabel('Region')# ajoute une étiquette pour l'axe des x
plt.ylabel('Effectifs')# ajoute une étiquette pour l'axe des y
plt.title('Nombre de visites par région') # ajoute un titre au graphique
plt.show() #  affiche le graphique




croise = pd.crosstab(visitesLoc['Region4'],Visites['config']) #utilise la fonction crosstab() de Pandas pour créer une table de contingence croisant les variables "Region4" 
                                                              #de visitesLoc et "config" de Visites. Cette table représente le nombre de visites pour chaque région et pour
                                                              #chaque système d'exploitation.
type(croise)
croise.plot(kind="bar",stacked=True)#L'argument kind="bar" spécifie que nous voulons un graphique en barres. L'argument stacked=True empile les barres pour chaque région.
plt.xlabel('Region')
plt.ylabel('Effectifs')
plt.title('Nombre de visites par région avec la répartition des systèmes')
plt.show()


# regroupement par heure de la journée et calcul du nombre d'actions
# Nous avons finalement décider de ne pas la continuer car il fallait récuperer d'abord l'heure en séparant les minutes et les secondes avec la methode split
# puis compter pour chaque visite associée à cette heure
#visitesActionDansVisites["nb"] = 1

#grap3 = visitesActionDansVisites[["heure", "nb"]].groupby("heure").sum()
#grap3.plot(kind="bar",legend=False)
#plt.title('Nombre dactions par heure')
#plt.xlabel('Heure')
#plt.ylabel('Nombre dactions')
#plt.show()



# Visite Region ET type actions
# Nous n'avons pas réussi à identifier les types des actions donc nous avons laisser seulement le numéro de l'action
croise2 = pd.crosstab(visitesLoc['Region4'],visitesLoc['Referer_type'])
type(croise)
croise2.plot(kind="bar",stacked=True)
plt.xlabel('Region')
plt.ylabel('Effectifs')
plt.title('Nombre de visites par région avec la répartition des types dActions')
plt.show()
